package lpm;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class LongestPrefixMatcher {
	List<Integer> ips;
	List<Byte> prefixLengths;
	List<Integer> portNumbers;
	//List<Integer> networkParts;
	//Set<Byte> masks;
	Map<Integer, Integer> foundMatches;
  /**
   * You can use this function to initialize variables.
   */
    public LongestPrefixMatcher() {
        ips = new ArrayList<>();
        prefixLengths = new ArrayList<>();
        portNumbers = new ArrayList<>();
        //networkParts = new ArrayList<>();
        
    }
    
    //List<Integer> maskMatch = new ArrayList<>();
    //List<Integer> maskMatchPortnumber = new ArrayList<>();
    
    /**
     * Looks up an IP address in the routing tables
     * @param ip The IP address to be looked up in integer representation
     * @return The port number this IP maps to
     */
    public int lookup(int ip) {
    	
    	foundMatches = new HashMap<>();
    	
    
    	
    	for (int i = 0; i < ips.size(); i++) {
    		
    		//System.out.println("IP " + ips.get(i) +" PrefixL " + (32 - prefixLengths.get(i)));
    		
    		int givenIP = ip >> (32 - prefixLengths.get(i));
    		int compareIP = ips.get(i) >> (32 - prefixLengths.get(i));
    		
    		if (givenIP == compareIP) {
    			//maskMatch.add(compareIP);
    			//maskMatchPortnumber.add(portNumbers.get(i));
    			foundMatches.put(compareIP, portNumbers.get(i));
    			System.out.println(portNumbers.get(i));
    		}	
    	
    	}
    	
    	if (foundMatches.size() != 0) {
        	Set<Integer> keys = foundMatches.keySet();
        	
        	
        	int longest = 0;
        	for (Integer k:keys) {
        		if (k > longest) {
        			longest = k;
        		}
        	}
        	return foundMatches.get(longest);
    	}

    	
    	
    	
        // TODO: Look up this route
    	/*
    	char[] ipCar = (ipToHuman(ip)).toCharArray(); 	
    	for (int i = 0; i < ips.size(); i++) {
    		char[] current = ips.get(i).toCharArray();
    		int noMatch = 0;
    		int loopLength = 0;
    		if (ipCar.length > current.length) {
    			loopLength = current.length;
    		} else {
    			loopLength = ipCar.length;
    		}
    		
    		for (int j = 0; j < loopLength; j++) {
    			if (ipCar[j] != current[j]) {
    				noMatch++;
    			}
    		}
    		if (noMatch == 0) {
    			return portNumbers.get(i);
    		}
   
    	} */
        return -1;
    }

    /**
     * Adds a route to the routing tables
     * @param ip The IP the block starts at in integer representation
     * @param prefixLength The number of bits indicating the network part
     *                     of the address range (notation ip/prefixLength)
     * @param portNumber The port number the IP block should route to
     */
    public void addRoute(int ip, byte prefixLength, int portNumber) {
        // TODO: Store this route for later use in lookup() method
    	ips.add(ip);
    	prefixLengths.add(prefixLength);
    	portNumbers.add(portNumber);	
    }

    /**
     * Converts an integer representation IP to the human readable form
     * @param ip The IP address to convert
     * @return The String representation for the IP (as xxx.xxx.xxx.xxx)
     */
    private String ipToHuman(int ip) {
        return Integer.toString(ip >> 24 & 0xff) + "." +
                Integer.toString(ip >> 16 & 0xff) + "." +
                Integer.toString(ip >> 8 & 0xff) + "." +
                Integer.toString(ip & 0xff);
    }

    /**
     * Parses an IP
     * @param ipString The IP address to convert
     * @return The integer representation for the IP
     */
    private int parseIP(String ipString) {
        String[] ipParts = ipString.split("\\.");

        int ip = 0;
        for (int i = 0; i < 4; i++) {
            ip |= Integer.parseInt(ipParts[i]) << (24 - (8 * i));
        }

        return ip;
    }
}
